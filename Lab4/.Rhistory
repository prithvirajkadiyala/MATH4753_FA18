knitr::opts_chunk$set(echo = TRUE)
getwd()
DDT = read.csv("DDT.csv", header=TRUE, sep=",")
head(DDT)
m=with(DDT, as.numeric(levels(factor(MILE))))
colm = c()
for (i in 1:length(DDT$MILE)) {
colm[i]=which(DDT$MILE[i]==m)
}
coplot(LENGTH~WEIGHT|RIVER*SPECIES,data=DDT,col=colm)
m=with(ddt, as.numeric(levels(factor(MILE))))
getwd()
DDT = read.csv("DDT.csv", header=TRUE, sep=",")
head(DDT)
m=with(DDT, as.numeric(levels(factor(MILE))))
colm = c()
for (i in 1:length(DDT$MILE)) {
colm[i]=which(DDT$MILE[i]==m)
}
coplot(LENGTH~WEIGHT|RIVER*SPECIES,data=DDT,col=colm)
coplot(LENGTH~WEIGHT|RIVER*SPECIES,data=DDT,col=colm)
m=with(DDT, as.numeric(levels(factor(MILE))))
m
DDT
m=with(DDT, as.numeric(levels(factor(MILE))))
m=with(DDT, as.numeric(levels(factor(MILE))))
m=with(DDT, as.numeric(levels(factor(MILE))))
m=with(DDT, as.numeric(levels(factor(MILE))))
m
DDT = read.csv("DDT.csv", header=TRUE, sep=",")
head(DDT)
m=subset(DDT,RIVER=="FCM" & SPECIES=="CCATFISH",)
DDT = read.csv("DDT.csv", header=TRUE, sep=",")
head(DDT)
m=ddt[ddt$RIVER=="FCM" & ddt$SPECIES=="CCATFISH",]
ddt = read.csv("DDT.csv", header=TRUE, sep=",")
head(ddt)
m=ddt[ddt$RIVER=="FCM" & ddt$SPECIES=="CCATFISH",]
m
ddt = read.csv("DDT.csv", header=TRUE, sep=",")
m=ddt[ddt$RIVER=="FCM" & ddt$SPECIES=="CCATFISH",]
m
ddt = read.csv("DDT.csv", header=TRUE, sep=",")
m=ddt[ddt$RIVER=="FCM" & ddt$SPECIES=="CCATFISH",]
m
mean(m$DDT)
ddt = read.csv("DDT.csv", header=TRUE, sep=",")
m=ddt[ddt$RIVER=="FCM" & ddt$SPECIES=="CCATFISH",]
m
mean(m$DDT)
ddt = read.csv("DDT.csv", header=TRUE, sep=",")
m=ddt[ddt$RIVER=="FCM" & ddt$SPECIES=="CCATFISH",]
m
mean(m$DDT)
mtbe=read.table(file.choose(),sep=",",header=TRUE)
head(mtbe) # First six lines
dim(mtbe) # rows and columns
ind=sample(1:223,5,replace=FALSE) # random indices
mtbe[ind,]
mtbeo=na.omit(mtbe)
head(mtbeo)
depth=mtbeo[mtbeo$Aquifier=="Unconsoli",]$Depth
sd(depth)
mtbe=read.csv("MTBE.csv")
head(mtbe) # First six lines
dim(mtbe) # rows and columns
ind=sample(1:223,5,replace=FALSE) # random indices
mtbe[ind,]
mtbeo=na.omit(mtbe)
head(mtbeo)
depth=mtbeo[mtbeo$Aquifier=="Unconsoli",]$Depth
sd(depth)
mtbe=read.csv("MTBE.csv")
head(mtbe) # First six lines
dim(mtbe) # rows and columns
ind=sample(1:223,5,replace=FALSE) # random indices
mtbe[ind,]
mtbeo=na.omit(mtbe)
head(mtbeo)
depth=mtbeo[mtbeo$Aquifier=="Bedrock",]$Depth
sd(depth)
eq=read.csv("EARTHQUAKE.csv")
head(eq) # First six lines
dim(eq) # rows and columns
ind=sample(1:2929,30,replace=FALSE) # random indices
eq[ind,]
quartz()
eq=read.csv("EARTHQUAKE.csv")
head(eq) # First six lines
dim(eq) # rows and columns
ind=sample(1:2929,30,replace=FALSE) # random indices
eq[ind,]
plot(ts(eq$MAG))
median(eq$MAGNITUDE)
library(qcc)
install.packages("qcc")
freq=c(15,8,63,20)
RL=c("None", "Both", "LegsOnly", "WheelsOnly")
l=rep(RL, freq)
pareto.chart(freq)
pareto<-function(x,mn="Pareto barplot",...){  # x is a vector
x.tab=table(x)
xx.tab=sort(x.tab, decreasing=TRUE,index.return=FALSE)
cumsum(as.vector(xx.tab))->cs
length(x.tab)->lenx
bp<-barplot(xx.tab,ylim=c(0,max(cs)),las=2)
lb<-seq(0,cs[lenx],l=11)
axis(side=4,at=lb,labels=paste(seq(0,100,length=11),"%",sep=""),las=1,line=-1,col="Blue",col.axis="Red")
for(i in 1:(lenx-1)){
segments(bp[i],cs[i],bp[i+1],cs[i+1],col=i,lwd=2)
}
title(main=mn,...)
}
freq=c(15,8,63,20)
RL=c("None", "Both", "LegsOnly", "WheelsOnly")
l=rep(RL, freq)
pareto.chart(freq)
pareto<-function(x,mn="Pareto barplot",...){  # x is a vector
x.tab=table(x)
xx.tab=sort(x.tab, decreasing=TRUE,index.return=FALSE)
cumsum(as.vector(xx.tab))->cs
length(x.tab)->lenx
bp<-barplot(xx.tab,ylim=c(0,max(cs)),las=2)
lb<-seq(0,cs[lenx],l=11)
axis(side=4,at=lb,labels=paste(seq(0,100,length=11),"%",sep=""),las=1,line=-1,col="Blue",col.axis="Red")
for(i in 1:(lenx-1)){
segments(bp[i],cs[i],bp[i+1],cs[i+1],col=i,lwd=2)
}
title(main=mn,...)
}
pareto<-function(x,mn="Pareto barplot",...){  # x is a vector
x.tab=table(x)
xx.tab=sort(x.tab, decreasing=TRUE,index.return=FALSE)
cumsum(as.vector(xx.tab))->cs
length(x.tab)->lenx
bp<-barplot(xx.tab,ylim=c(0,max(cs)),las=2)
lb<-seq(0,cs[lenx],l=11)
axis(side=4,at=lb,labels=paste(seq(0,100,length=11),"%",sep=""),las=1,line=-1,col="Blue",col.axis="Red")
for(i in 1:(lenx-1)){
segments(bp[i],cs[i],bp[i+1],cs[i+1],col=i,lwd=2)
}
title(main=mn,...)
}
freq=c(15,8,63,20)
RL=c("None", "Both", "LegsOnly", "WheelsOnly")
l=rep(RL, freq)
pareto(freq)
office=12
windows=32
explorer=6
pieData <- c(office,windows,explorer)
quartz()
office=12
windows=32
explorer=6
pieData <- c(office,windows,explorer)
pie(pieData, col=4:6, main="Microsoft Products with Security Issues", labels=c("Office", "Windows", "Explorer"))
office=12
windows=32
explorer=6
pieData <- c(office,windows,explorer)
pie(pieData, col=1:3, main="Microsoft Products with Security Issues", labels=c("Office", "Windows", "Explorer"))
office=12
windows=32
explorer=6
pieData <- c(office,windows,explorer)
pie(pieData, col=2:4, main="Microsoft Products with Security Issues", labels=c("Office", "Windows", "Explorer"))
DenialOfService=6
InformationDisclosure=8
RemoteCodeExecution=22
Spoofing=3
PrivilegeElevation=11
paretoData <- c(DenialOfService,InformationDisclosure,RemoteCodeExecution,Spoofing,PrivilegeElevation)
pareto(paretoData, col=2:7, main="Expected Reperrcussions from Security Issues")
DenialOfService=6
InformationDisclosure=8
RemoteCodeExecution=22
Spoofing=3
PrivilegeElevation=11
paretoData <- c(DenialOfService,InformationDisclosure,RemoteCodeExecution,Spoofing,PrivilegeElevation)
pareto(paretoData, col=2:7, main="Expected Reperrcussions from Security Issues")
DenialOfService=6
InformationDisclosure=8
RemoteCodeExecution=22
Spoofing=3
PrivilegeElevation=11
paretoData <- c(DenialOfService,InformationDisclosure,RemoteCodeExecution,Spoofing,PrivilegeElevation)
pareto(paretoData)
freq2.4.1=c(6,8,22,3,11)
Names2.4.1=c("Denial of Service","Information Disclosure","Remote Code Execution","Spoofing","Privilege Elevation")
n=rep(Names2.4.1,freq2.4.1)
pareto(n, mn="Security Bulletins")
freq=c(6,8,22,3,11)
Names=c("Denial of Service","Information Disclosure","Remote Code Execution","Spoofing","Privilege Elevation")
n=rep(Names,freq)
pareto(n, mn="Security Bulletins")
setwd("C:/Users/prith/OneDrive/Documents/MATH4753_FA18/Lab4")
setwd("C:/Users/prith/OneDrive/Documents/MATH4753_FA18/Lab4")
knitr::opts_chunk$set(echo = TRUE)
# construct QQ plot
normcheck(quad.lm)
# Two plots testing normality
normcheck(spruce.lm,shapiro.wilk = TRUE)
library(s20x)
trendscatter(Height~BHDiameter,f=0.5,data=spruce.df)
# Two plots testing normality
normcheck(spruce.lm,shapiro.wilk = TRUE)
# construct QQ plot
normcheck(quad.lm)
# construct QQ plot
normcheck(quad.lm,shapiro.wilk = TRUE)
#summarize quad.lm
summary(quad.lm)
spruce.lm=lm(Height~BHDiameter,data=spruce.df)
summary(spruce.lm)
anova(spruce.lm,quad.lm)
height.qfit=fitted(quad.lm)
height.qfit
#  RSS=residual sum of squares
RSS=with(spruce.df,sum((Height-height.qfit)^2))
RSS
# MSS=model sum of squares
MSS=with(spruce.df,sum((height.qfit-mean(Height))^2))
MSS
# TSS=total sum of squares
TSS=with(spruce.df,sum((Height-mean(Height))^2))
TSS
# Calculate MSS/TSS, and interpret it!
MSS/TSS
cooks20x(quad.lm)
quad2.lm=lm(Height~BHDiameter + I(BHDiameter^2) , data=spruce.df[-24,])
summary(quad2.lm)
summary(quad.lm)
